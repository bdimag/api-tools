using ApiTools.Codegen.Task.Configuration;
using Microsoft.Build.Framework;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace ApiTools.Codegen.Task
{
    /// <summary>
    /// Generates additional source files and creates client libraries.
    /// </summary>
    public partial class GenerateClients : ITask
    {
        private Config effectiveConfiguration;

        /// <summary>
        /// All CSharp compile files.
        /// </summary>
        [Required]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "MSBuild task parameter")]
        public ITaskItem[] CompileFiles { get; set; }

        /// <summary>
        /// JSON <see cref="Config"/> files.
        /// </summary>
        [Required]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "MSBuild task parameter")]
        public ITaskItem[] ConfigFiles { get; set; }

        /// <summary>
        /// The default directory where the generated files will be written.
        /// </summary>
        [Required]
        public string DefaultDirectory { get; set; }

        /// <summary>
        /// The default namespace that wil be used for generated files.
        /// </summary>
        [Required]
        public string DefaultNamespace { get; set; }

        /// <summary>
        /// Output parameter that contains all files generated by this task.
        /// </summary>
        [Output]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Performance", "CA1819:Properties should not return arrays", Justification = "MSBuild task parameter")]
        public string[] FileWrites { get; set; }

        /// <summary>
        /// Determines the absolute path for the specified <paramref name="path"/> relative to the other.
        /// </summary>
        /// <param name="path">A relative path.</param>
        /// <param name="relativeTo">An absolute path from which the path to <paramref name="path"/> is determined.</param>
        private static string GetAbsolutePath(string path, string relativeTo)
        {
            return new DirectoryInfo(Path.Combine(relativeTo, path)).FullName;
        }

        /// <summary>
        /// Write a message to the build output with 'high' imporance.
        /// </summary>
        /// <param name="message">The message that will be written to the output.</param>
        private void WriteMessage(string message, [CallerMemberName]string callerName = "")
        {
            BuildEngine.LogMessageEvent(new BuildMessageEventArgs(message, callerName, typeof(GenerateClients).FullName, MessageImportance.High));
        }

        /// <summary>
        /// Generates a single <see cref="Config"/> instance based on values from all configurations specified in the target project.
        /// </summary>
        /// <returns></returns>
        internal Config GetEffectiveConfiguration()
        {
            if (effectiveConfiguration == null)
            {
                var effConfig = new Config();

                // get the best values from all configurations
                foreach (var config in GetValidConfigurations().OrderBy(c => !c.Defaults))
                {
                    var configDirectory = Path.GetDirectoryName(config.Source);

                    if (!string.IsNullOrEmpty(config.DefaultNamespace))
                    {
                        effConfig.DefaultNamespace = config.DefaultNamespace;
                    }
                    if (!string.IsNullOrEmpty(config.DefaultOutputPath))
                    {
                        effConfig.DefaultOutputPath = GetAbsolutePath(config.DefaultOutputPath, configDirectory);
                    }
                    if (config.Projects != null)
                    {
                        // merge projects from all configs
                        foreach (var project in config.Projects)
                        {
                            var existingProject = effConfig.Projects.Find(project);
                            if (existingProject != null)
                            {
                                if (project.Enabled.HasValue)
                                {
                                    existingProject.Enabled = project.Enabled;
                                }
                                if (!string.IsNullOrEmpty(project.Namespace))
                                {
                                    existingProject.Namespace = project.Namespace;
                                }
                                if (!string.IsNullOrEmpty(project.Name))
                                {
                                    existingProject.Name = project.Name;
                                }
                                if (!string.IsNullOrEmpty(project.OutputPath))
                                {
                                    existingProject.OutputPath = GetAbsolutePath(project.OutputPath, configDirectory);
                                }
                            }
                            else
                            {
                                effConfig.Projects.Add(project);
                            }
                        }
                    }
                }

                // add defaults based on values known to the task
                if (string.IsNullOrEmpty(effConfig.DefaultOutputPath))
                {
                    effConfig.DefaultOutputPath = DefaultDirectory;
                }
                if (string.IsNullOrEmpty(effConfig.DefaultNamespace))
                {
                    effConfig.DefaultNamespace = DefaultNamespace;
                }

                // update each project with defaults from the overall config if needed
                foreach (var project in effConfig.Projects)
                {
                    if (string.IsNullOrEmpty(project.Namespace))
                    {
                        project.Namespace = effConfig.DefaultNamespace;
                    }
                    if (string.IsNullOrEmpty(project.Name))
                    {
                        project.Name = $"{project.Namespace}.{project.Type}";
                    }
                    if (string.IsNullOrEmpty(project.OutputPath))
                    {
                        project.OutputPath = Path.Combine(effConfig.DefaultOutputPath, $"{project.Name}_{project.Type}");
                    }
                }

                effectiveConfiguration = effConfig;
            }

            return effectiveConfiguration;
        }

        /// <summary>
        /// Retrieves configurations specified in the target project that can be deserialized.
        /// </summary>
        internal IEnumerable<Config> GetValidConfigurations()
        {
            var configFiles = new List<Config>();

            if (ConfigFiles != null)
            {
                foreach (var configFile in ConfigFiles)
                {
                    string configPath = configFile.GetMetadata("FullPath");
                    string defaults = configFile.GetMetadata("Default");
                    if (string.IsNullOrEmpty(configPath) || !File.Exists(configPath))
                    {
                        WriteMessage($"Invalid config path specified: \"{configFile.GetMetadata("FullPath")}\".");
                        continue;
                    }

                    Config config;
                    try
                    {
                        var jsonSerializerOptions = new JsonSerializerOptions();
                        jsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
                        config = JsonSerializer.Deserialize<Config>(File.ReadAllText(configPath), jsonSerializerOptions);
                    }
                    catch (JsonException ex)
                    {
                        WriteMessage($"Invalid config file at \"{configPath}\": {ex.Message}.");
                        continue;
                    }

                    config.Source = configPath;
                    config.Defaults = bool.TryParse(defaults, out bool result) && result;

                    configFiles.Add(config);
                }
            }

            return configFiles;
        }

        // main entry point of this task
        public bool Execute()
        {
            var fileWrites = new List<string>();
            using (var builder = new LibraryBuilder())
            {
                // add files
                foreach (var file in CompileFiles)
                {
                    var path = file.GetMetadata("FullPath");
                    if (File.Exists(path))
                    {
                        using (var stream = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                        {
                            builder.AddFile(stream);
                        }
                    }
                }

                // start building output
                foreach (var project in GetEffectiveConfiguration().Projects)
                {
                    if (project.Enabled != true)
                    {
                        WriteMessage($"Skipping project \"{project.Name}\" because it is not enabled.");
                        continue;
                    }

                    WriteMessage($"Starting build of {project.Type} project \"{project.Name}\" in directory \"{project.OutputPath}\"");
                    foreach (var file in builder.Build(project.Type, project.Name, project.Namespace))
                    {
                        var filePath = Path.Combine(project.OutputPath, file.Path);
                        fileWrites.Add(filePath);

                        // make sure the target directory exists
                        var directory = Path.GetDirectoryName(filePath);
                        if (!Directory.Exists(directory))
                        {
                            Directory.CreateDirectory(directory);
                        }

                        // write the file to disk
                        using (var fileStream = File.Open(filePath, FileMode.Create, FileAccess.Write, FileShare.Read))
                        using (var streamWriter = new StreamWriter(fileStream))
                        {
                            WriteMessage($"Writing {project.Type} project file \"{filePath}\"");

                            file.Write(streamWriter);
                        }
                    }
                }
            }

            FileWrites = fileWrites.ToArray();

            return true;
        }
    }
}