using ApiTools.Codegen.Task.Configuration;
using Microsoft.Build.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Reflection = System.Reflection;

namespace ApiTools.Codegen.Task
{
    public partial class CreateClientsFromAssembly : ITask
    {
        private Config effectiveConfiguration;

        /// <summary>
        /// The entry-assembly that will be used to generate additional API projects and client types.
        /// </summary>
        [Required]
        public string Assembly { get; set; }

        /// <summary>
        /// JSON <see cref="Config"/> files.
        /// </summary>
        [Required]
        public ITaskItem[] ConfigFiles { get; set; }

        /// <summary>
        /// Output parameter that contains all files generated by this task.
        /// </summary>
        [Output]
        public string[] FileWrites { get; set; }

        /// <summary>
        /// Determines the absolute path for the specified <paramref name="path"/> relative to the other.
        /// </summary>
        /// <param name="path">A relative path.</param>
        /// <param name="relativeTo">An absolute path from which the path to <paramref name="path"/> is determined.</param>
        private string GetAbsolutePath(string path, string relativeTo)
        {
            WriteMessage($"@@@ \"{path}\" from \"{relativeTo}\".");
            return new DirectoryInfo(Path.Combine(relativeTo, path)).FullName;
        }

        /// <summary>
        /// Retrieves all types from an assembly that have the <see cref="ClientTypeAttribute"/> applied.
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        private Type[] GetTypes(string path)
        {
            AppDomain.CurrentDomain.AssemblyResolve += ResolveLocalAssembly;

            var assembly = Reflection.Assembly.LoadFrom(path);
            var assemblyTypes = new List<Type>();
            foreach (var type in assembly.GetTypes())
            {
                // types must have the `ClientTypeAttribute`
                if (type.IsDefined(typeof(ClientTypeAttribute), false))
                {
                    assemblyTypes.Add(type);
                }
            }

            AppDomain.CurrentDomain.AssemblyResolve -= ResolveLocalAssembly;

            return assemblyTypes.ToArray();
        }

        /// <summary>
        /// Attempts to resolve an assembly by looking for the named-dll in the same directory as the specified <see cref="Assembly" />, or in this task's codebase.
        /// </summary>
        /// <returns>An <see cref="Reflection.Assembly"/> if the named-dll exists, otherwise <see langword="null"/>.</returns>
        private Reflection.Assembly ResolveLocalAssembly(object sender, System.ResolveEventArgs args)
        {
            var assemblyName = new Reflection.AssemblyName(args.Name);
            var expectedPath = Path.Combine(Path.GetDirectoryName(Assembly), assemblyName.Name + ".dll");
            if (File.Exists(expectedPath))
            {
                return Reflection.Assembly.LoadFrom(expectedPath);
            }

            return null;
        }

        /// <summary>
        /// Write a message to the build output with 'high' imporance.
        /// </summary>
        /// <param name="message">The message that will be written to the output.</param>
        private void WriteMessage(string message, [CallerMemberName]string callerName = "")
        {
            BuildEngine.LogMessageEvent(new BuildMessageEventArgs(message, callerName, typeof(CreateClientsFromAssembly).FullName, MessageImportance.High));
        }

        /// <summary>
        /// Generates a single <see cref="Config"/> based on all configuration files that were provided to the task.
        /// </summary>
        /// <returns></returns>
        internal Config GetEffectiveConfiguration()
        {
            if (effectiveConfiguration == null)
            {
                var effConfig = new Config();

                if (ConfigFiles != null)
                {
                    foreach (var configFile in ConfigFiles)
                    {
                        string configPath = configFile.GetMetadata("FullPath");
                        if (string.IsNullOrEmpty(configPath) || !File.Exists(configPath))
                        {
                            WriteMessage($"Invalid config path specified: \"{configFile.GetMetadata("FullPath")}\".");
                            continue;
                        }

                        string configDirectory = Path.GetDirectoryName(configPath);
                        Config config = null;
                        try
                        {
                            var jsonSerializerOptions = new JsonSerializerOptions();
                            jsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());
                            config = JsonSerializer.Deserialize<Config>(File.ReadAllText(configPath), jsonSerializerOptions);
                        }
                        catch (JsonException ex)
                        {
                            WriteMessage($"Invalid config file at \"{configPath}\": {ex.Message}.");
                            continue;
                        }
                        catch
                        {
                            WriteMessage($"Invalid config file at \"{configPath}\".");
                            continue;
                        }

                        WriteMessage($"Evaluating config file at \"{configPath}\".");

                        if (!string.IsNullOrEmpty(config.DefaultNamespace))
                        {
                            effConfig.DefaultNamespace = config.DefaultNamespace;
                        }
                        if (!string.IsNullOrEmpty(config.DefaultOutputPath))
                        {
                            effConfig.DefaultOutputPath = GetAbsolutePath(config.DefaultOutputPath, configDirectory);
                        }
                        if (config.Projects != null)
                        {
                            foreach (var project in config.Projects)
                            {
                                var existingProject = effConfig.Projects.Find(project);
                                if (existingProject != null)
                                {
                                    if (project.Enabled.HasValue)
                                    {
                                        existingProject.Enabled = project.Enabled;
                                    }
                                    if (!string.IsNullOrEmpty(project.Namespace))
                                    {
                                        existingProject.Namespace = project.Namespace;
                                    }
                                    if (!string.IsNullOrEmpty(project.Name))
                                    {
                                        existingProject.Name = project.Name;
                                    }
                                    if (!string.IsNullOrEmpty(project.OutputPath))
                                    {
                                        existingProject.OutputPath = GetAbsolutePath(project.OutputPath, configDirectory);
                                    }
                                }
                                else
                                {
                                    effConfig.Projects.Add(project);
                                }
                            }
                        }
                    }
                }

                // defaults based on values known to the task
                if (string.IsNullOrEmpty(effConfig.DefaultOutputPath))
                {
                    effConfig.DefaultOutputPath = Path.GetDirectoryName(Assembly);
                }
                if (string.IsNullOrEmpty(effConfig.DefaultNamespace))
                {
                    effConfig.DefaultNamespace = Path.GetFileNameWithoutExtension(Assembly);
                }
                foreach (var project in effConfig.Projects)
                {
                    if (string.IsNullOrEmpty(project.Namespace))
                    {
                        project.Namespace = effConfig.DefaultNamespace;
                    }
                    if (string.IsNullOrEmpty(project.Name))
                    {
                        project.Name = $"{project.Namespace}.{project.Type}";
                    }
                    if (string.IsNullOrEmpty(project.OutputPath))
                    {
                        project.OutputPath = Path.Combine(effConfig.DefaultOutputPath, $"{project.Name}_{project.Type}");
                    }
                }

                effectiveConfiguration = effConfig;
            }

            WriteMessage(JsonSerializer.Serialize(effectiveConfiguration, new JsonSerializerOptions { IgnoreNullValues = true, WriteIndented = true }));

            return effectiveConfiguration;
        }

        // main entry point of this task
        public bool Execute()
        {
            WriteMessage("Entered Task.");

            Type[] types = null;
            try
            {
                types = GetTypes(Assembly);

                WriteMessage($"Found {types.Length} type(s).");
            }
            catch (Exception ex)
            {
                WriteMessage($"Failed to retrieve assemblies: {ex.Message}.");

                return false;
            }

            var fileWrites = new List<string>();
            using (var builder = new LibraryBuilder(types))
            {
                foreach (var project in GetEffectiveConfiguration().Projects)
                {
                    if (project.Enabled != true)
                    {
                        WriteMessage($"Skipping project \"{project.Name}\" because it is not enabled.");
                        continue;
                    }

                    WriteMessage($"Starting build of {project.Type} project \"{project.Name}\" in directory \"{project.OutputPath}\"");
                    foreach (var file in builder.Build(project.Type, project.Name, project.Namespace))
                    {
                        var filePath = Path.Combine(project.OutputPath, file.Path);
                        fileWrites.Add(filePath);

                        // make sure the target directory exists
                        var directory = Path.GetDirectoryName(filePath);
                        if (!Directory.Exists(directory))
                        {
                            Directory.CreateDirectory(directory);
                        }

                        // write the file to disk
                        using (var fileStream = File.OpenWrite(filePath))
                        using (var streamWriter = new StreamWriter(fileStream))
                        {
                            WriteMessage($"Writing {project.Type} project file \"{filePath}\"");

                            file.Write(streamWriter);
                        }
                    }
                }
            }

            FileWrites = fileWrites.ToArray();

            return true;
        }
    }
}