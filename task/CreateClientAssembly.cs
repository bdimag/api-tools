using Microsoft.Build.Framework;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using static System.AppDomain;
using Reflection = System.Reflection;

namespace ApiTools.Codegen.Task
{
    public partial class CreateClientsFromAssembly : ITask
    {
        private Config effectiveConfiguration;

        /// <summary>
        /// The entry-assembly that will be used to generate additional API projects and client types.
        /// </summary>
        [Required]
        public string Assembly { get; set; }

        /// <summary>
        /// JSON <see cref="Config"/> files.
        /// </summary>
        [Required]
        public ITaskItem[] ConfigFiles { get; set; }

        /// <summary>
        /// Output parameter that contains all files generated by this task.
        /// </summary>
        [Output]
        public string[] FileWrites { get; set; }

        /// <summary>
        /// Retrieves all types from an assembly that have the <see cref="ClientTypeAttribute"/> applied.
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        private Type[] GetTypes(string path)
        {
            CurrentDomain.AssemblyResolve += ResolveLocalAssembly;

            var assembly = Reflection.Assembly.LoadFrom(path);
            var assemblyTypes = new List<Type>();
            foreach (var type in assembly.GetTypes())
            {
                // types must have the `ClientTypeAttribute`
                if (type.IsDefined(typeof(ClientTypeAttribute), false))
                {
                    assemblyTypes.Add(type);
                }
            }

            // TODO make sure this is a safe time to stop resolving local dlls;
            //      will still need to retrieve members and member attributes
            CurrentDomain.AssemblyResolve -= ResolveLocalAssembly;

            return assemblyTypes.ToArray();
        }

        /// <summary>
        /// Attempts to resolve an assembly by looking for the named-dll in the same directory as the specified <see cref="Assembly" />, or in this task's codebase.
        /// </summary>
        /// <returns>An <see cref="Reflection.Assembly"/> if the named-dll exists, otherwise <see langword="null"/>.</returns>
        private Reflection.Assembly ResolveLocalAssembly(object sender, System.ResolveEventArgs args)
        {
            var assemblyName = new Reflection.AssemblyName(args.Name);
            var expectedPath = Path.Combine(Path.GetDirectoryName(Assembly), assemblyName.Name + ".dll");
            if (File.Exists(expectedPath))
            {
                return Reflection.Assembly.LoadFrom(expectedPath);
            }

            return null;
        }

        /// <summary>
        /// Write a message to the build output with 'high' imporance.
        /// </summary>
        /// <param name="message">The message that will be written to the output.</param>
        private void WriteMessage(string message, [CallerMemberName]string callerName = "")
        {
            BuildEngine.LogMessageEvent(new BuildMessageEventArgs(message, callerName, typeof(CreateClientsFromAssembly).FullName, MessageImportance.High));
        }

        /// <summary>
        /// Generates a single <see cref="Config"/> based on all configuration files that were provided to the task.
        /// </summary>
        /// <returns></returns>
        internal Config GetEffectiveConfiguration()
        {
            if (effectiveConfiguration == null)
            {
                var effConfig = new Config();
                var allProjects = new List<ProjectSettings>();

                if (ConfigFiles != null)
                {
                    // TODO if there's more than one file, properties are overwritten--order should be Defaults.json (provided
                    //      here) first, following by any others provided by the project that invoked the task.
                    foreach (var configFile in ConfigFiles)
                    {
                        Config config = null;
                        try
                        {
                            var jsonSerializerOptions = new JsonSerializerOptions();
                            jsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());

                            config = JsonSerializer.Deserialize<Config>(File.ReadAllText(configFile.GetMetadata("Identity")), jsonSerializerOptions);
                        }
                        catch (JsonException ex)
                        {
                            WriteMessage($"Invalid config file at \"{configFile.GetMetadata("Identity")}\": {ex.Message}.");
                            continue;
                        }
                        catch
                        {
                            WriteMessage($"Invalid config file at \"{configFile.GetMetadata("Identity")}\".");
                            continue;
                        }

                        if (!string.IsNullOrEmpty(config.DefaultNamespace))
                        {
                            effConfig.DefaultNamespace = config.DefaultNamespace;
                        }
                        if (!string.IsNullOrEmpty(config.DefaultOutputPath))
                        {
                            effConfig.DefaultOutputPath = config.DefaultOutputPath;
                        }
                        if (config.Projects != null)
                        {
                            foreach (var project in config.Projects)
                            {
                                var existingProject = allProjects.FirstOrDefault(p => project.Equals(p));
                                if (existingProject != null)
                                {
                                    if (project.Enabled.HasValue)
                                    {
                                        existingProject.Enabled = project.Enabled;
                                    }
                                    if (!string.IsNullOrEmpty(project.Namespace))
                                    {
                                        existingProject.Namespace = project.Namespace;
                                    }
                                    if (!string.IsNullOrEmpty(project.Name))
                                    {
                                        existingProject.Name = project.Name;
                                    }
                                    if (!string.IsNullOrEmpty(project.OutputPath))
                                    {
                                        existingProject.OutputPath = project.OutputPath;
                                    }
                                }
                                else
                                {
                                    allProjects.Add(project);
                                }
                            }
                        }
                    }
                }

                effConfig.Projects = allProjects.ToArray();

                // defaults based on values known to the task
                if (string.IsNullOrEmpty(effConfig.DefaultOutputPath))
                {
                    effConfig.DefaultOutputPath = Path.GetDirectoryName(Assembly);
                }
                if (string.IsNullOrEmpty(effConfig.DefaultNamespace))
                {
                    effConfig.DefaultNamespace = Path.GetFileNameWithoutExtension(Assembly);
                }
                foreach (var project in effConfig.Projects)
                {
                    if (string.IsNullOrEmpty(project.OutputPath))
                    {
                        project.OutputPath = effConfig.DefaultOutputPath;
                    }
                    if (string.IsNullOrEmpty(project.Namespace))
                    {
                        project.Namespace = effConfig.DefaultNamespace;
                    }
                    if (string.IsNullOrEmpty(project.Name))
                    {
                        project.Name = $"{project.Namespace}.{project.Type}";
                    }
                }

                effectiveConfiguration = effConfig;
            }

            return effectiveConfiguration;
        }

        // main entry point of this task
        public bool Execute()
        {
            WriteMessage("Entered Task.");

            Type[] types = null;
            try
            {
                types = GetTypes(Assembly);

                WriteMessage($"Found {types.Length} type(s).");
            }
            catch (Exception ex)
            {
                WriteMessage($"Failed to retrieve assemblies: {ex.Message}.");

                return false;
            }

            var fileWrites = new List<string>();
            using (var builder = new LibraryBuilder())
            {
                builder.Add();

                foreach (var project in GetEffectiveConfiguration().Projects)
                {
                    WriteMessage($"Starting build of {project.Type} project \"{project.Name}\" in directory \"{project.OutputPath}\"");
                    foreach (var file in builder.Build())
                    {
                        var filePath = Path.Combine(project.OutputPath, file.Path);
                        fileWrites.Add(filePath);

                        // write the file to disk
                        using (var fileStream = File.OpenWrite(filePath))
                        using (var streamWriter = new StreamWriter(fileStream))
                        {
                            // TODO if outputing to another, existing project, the project file itself could be updated
                            //      instead of overwriting to allow multiple assemblies to be built into a single
                            //      client library.

                            WriteMessage($"Writing {project.Type} project file \"{filePath}\"");
                            file.Write(streamWriter);
                        }
                    }
                }
            }

            // TODO if writing to another project in the solution, might not want the files to be deleted during clean;
            //      this could be specified in the config, or perhaps can be determined automatically based on output path.
            FileWrites = fileWrites.ToArray();

            return true;
        }
    }
}